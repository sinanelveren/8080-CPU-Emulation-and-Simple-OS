        ; 8080 assembler code
        .hexfile Random50.hex
        .binfile Random50.com
        ; try "hex" for downloading in hex format
        .download bin  
        .objcopy gobjcopy
        .postbuild echo "OK!"
        ;.nodump

	; OS call list
PRINT_B		equ 1
PRINT_MEM	equ 2
READ_B		equ 3
READ_MEM	equ 4
PRINT_STR	equ 5
READ_STR	equ 6
GET_RND		equ 7

	; Position for stack pointer
stack   equ 0F000h

	org 000H
	jmp begin

	; Start of our Operating System
GTU_OS:	PUSH D
	push D
	push H
	push psw
	nop	; This is where we run our OS in C++, see the CPU8080::isSystemCall()
		; function for the detail.
	pop psw
	pop h
	pop d
	pop D
	ret
	; ---------------------------------------------------------------
	; YOU SHOULD NOT CHANGE ANYTHING ABOVE THIS LINE        

	; This program generate 50 random bytes and sorts them increasly.
	; The program also prints sorted numbers
	;sort subrutine in C:
	;for (int j = 1; j < size; j++)
	;	for (int i = 0; i <size - j; i++)
	;		if (a[i] > a[i +1])
	;			swap(a[i], a[i+1])				

info:	dw 'Random numbers has been generated.',00AH,00H ; null terminated string
info2:	dw 'The numbers has been sorted.',00AH,00H ; null terminated string
	; Position for random numbers
arr	equ 0500h




begin:
	LXI SP,stack 	; always initialize the stack pointer
        mvi C, 50	; init E with 50 ; counter up to zero
	LXI D, arr	; D&E = arr  ;array starts at this location

loop:
			; generate 50 random number and store them in arr location
	MVI A, GET_RND	; store the OS call code to A to generate random byte and assign it to B
			; Now we will call the OS to store generated byte to register B 
	call GTU_OS	; call the OS
			; has been stored value in the register B

			
	MOV A, B	; A = B
	STAX D		; MEM[D] = B
	INX D		; D = D + 2	; for next byte

	DCR C		; C = C - 1 ;counter
	JNZ loop	; goto loop if C!= 0

	
			;print screen to generated numbers
	MVI D, 50	;50
	LXI B, arr

writeArr:		; has been writting all random numbers
	MVI A, PRINT_MEM; store the OS call code to A for print B MEM
	call GTU_OS	; call the OS
	
	INX B		; B = B + 2 ;for next byte
	DCR D		; D = D - 1 ;counter
	JNZ writeArr	; goto loop if D != 0
	



			;;; show to user some info 
	LXI B, info	; put the address of string in registers B and C
	MVI A, PRINT_STR; store the OS call code to A
	call GTU_OS	; call the OS




	LXI H, arr	; H&D = mem(arr) 	source
;	LXI D, sortArr	; D&E = mem(sortArr)	destination

	MVI D, 0	;counter 2 = 0
	MVI C, 1	;counter 1 = 1
	

sortLoop:		;sort them
	LXI H, arr

	INR C		;c1 ++	
	MOV E, C
	MVI A, 50	;50
	SUB E		; Size - counter1 < 0 ? check counter 1 up to 50
	JM break 	; a ?< e   sign bit is 1


	MVI A, 51	;counter2 = 50-counter1 up to zero
	SUB C
	MOV D, A	;size-k counter2

;	
innloop:
	MOV E, D	; E = D
	MVI A, 0	; A = 0
	SUB E		; A = A - E
	JZ sortLoop	; if (A < = 0) jump sortLoop
		
	DCR D		;c2--	
	
			;;TEST for in for
;MOV B,C
;MVI A, PRINT_B; store the OS call code to A for print B MEM
;call GTU_OS	; call the OS
;MOV B,D
;MVI A, PRINT_B; store the OS call code to A for print B MEM
;call GTU_OS	; call the OS
			;;END TEST for in for

	MOV B, M	; first
	INX H		; next byte HL = hL + 1
	
	MOV E, B	; first
	SUB A
	MOV A, M	; second : read from memory B = mem(H&L)
	
	CMP E		;a ?< b	swap ; will be sort incr order
	JZ  back
	JC swap	

back:
	JMP innLoop

swap:

	MOV A, M	; exchange 
	DCX H
	MOV B, M
	
	MOV M, A	
	INX H
	MOV M, B
;MOV B, A
;MVI A, PRINT_B; store the OS call code to A for print B MEM
;call GTU_OS	; call the OS	
;MOV B, E
;MVI A, PRINT_B; store the OS call code to A for print B MEM
;call GTU_OS	; call the OS

	JMP back


break:


	
	MVI D, 50	;50
	LXI B, arr
loopWrite:
			;show all sorted data
	MVI A, PRINT_MEM; store the OS call code to A for print B MEM
	call GTU_OS	; call the OS
	
	INX B		; B = B + 2 ;for next byte
	DCR D		; D = D - 1 ;counter
	JNZ loopWrite	; goto loop if D != 0
	


			;;; show to user some info 
	LXI B, info2	; put the address of string in registers B and C
	MVI A, PRINT_STR; store the OS call code to A
	call GTU_OS	; call the OS



	hlt		; end program





